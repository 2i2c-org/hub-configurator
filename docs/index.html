<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiered Product Configurator</title>

  <!-- Tailwind Play CDN (no build step) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg:#ffffff; --fg:#111827; }
    body { background: var(--bg); color: var(--fg); }
    .container { max-width: 1200px; }
  </style>

  <!-- React + ReactDOM UMD (no bundler needed) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel Standalone for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Google Sheets CSV loader (sets window.CATALOG_OVERRIDE if URL params present) -->
  <script>
  /**
   * Load catalog from three published CSVs (Google Sheets → File → Share → Publish to web → CSV).
   * URL params: ?features=<CSV>&tierrules=<CSV>&options=<CSV>
   * Exposes window.CATALOG_OVERRIDE = catalogArray when successful.
   */
  (function(){
    const SHEET_TIERS = ["Essential", "Advanced", "Premier"];

    function parseCSV(text) {
      const rows = [];
      let cur = [], val = "", i = 0, inQ = false;
      while (i < text.length) {
        const c = text[i];
        if (inQ) {
          if (c === '"') {
            if (text[i+1] === '"') { val += '"'; i += 2; continue; }
            inQ = false; i++; continue;
          }
          val += c; i++; continue;
        }
        if (c === '"') { inQ = true; i++; continue; }
        if (c === ',') { cur.push(val); val = ""; i++; continue; }
        if (c === '\n' || c === '\r') {
          if (c === '\r' && text[i+1] === '\n') i++;
          cur.push(val); rows.push(cur); cur = []; val = ""; i++; continue;
        }
        val += c; i++;
      }
      cur.push(val); rows.push(cur);
      const header = rows.shift().map(h => h.trim());
      return rows.filter(r => r.length && r.some(x => String(x).trim() !== ""))
                 .map(r => Object.fromEntries(header.map((h, idx) => [h, r[idx] ?? ""])));
    }

    async function fetchCSV(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`Fetch failed ${r.status} for ${url}`);
      return parseCSV(await r.text());
    }

    async function loadCatalogFromSheets({ featuresCsv, tierrulesCsv, optionsCsv }) {
      const [features, rules, options] = await Promise.all([
        fetchCSV(featuresCsv),
        fetchCSV(tierrulesCsv),
        fetchCSV(optionsCsv),
      ]);

      const frows = features.map(x => ({
        id: String(x.id || x.ID || "").trim(),
        group: String(x.group || x.Group || "").trim(),
        label: String(x.label || x.Label || "").trim(),
        help: String(x.help || x.Help || "").trim(),
      })).filter(x => x.id);

      const orows = options.map(x => ({
        id: String(x.id || x.ID || "").trim(),
        tier: String(x.tier || x.Tier || "").trim(),
        option: String(x.option || x.Option || "").trim(),
      })).filter(x => x.id && x.tier);

      const optsByKey = new Map();
      for (const o of orows) {
        const k = `${o.id}|||${o.tier}`;
        if (!optsByKey.has(k)) optsByKey.set(k, []);
        if (o.option) optsByKey.get(k).push(o.option);
      }

      const rrows = rules.map(x => ({
        id: String(x.id || x.ID || "").trim(),
        tier: String(x.tier || x.Tier || "").trim(),
        kind: String(x.kind || x.Kind || "").trim().toLowerCase(),
        available: String(x.available ?? x.Available ?? "").trim(),
        text: String(x.text ?? x.Text ?? "").trim(),
        default: String(x.default ?? x.Default ?? "").trim(),
      })).filter(x => x.id && x.tier && x.kind);

      const rulesByKey = new Map();
      for (const r of rrows) rulesByKey.set(`${r.id}|||${r.tier}`, r);

      const catalog = [];
      for (const f of frows) {
        const perTier = {};
        for (const T of SHEET_TIERS) {
          const k = `${f.id}|||${T}`;
          const rule = rulesByKey.get(k);
          if (!rule) continue;

          if (rule.kind === "flag") {
            const bool = /^true|1|yes$/i.test(rule.available);
            perTier[T] = { kind: "flag", available: bool };
          } else if (rule.kind === "single") {
            perTier[T] = { kind: "single", text: rule.text };
          } else if (rule.kind === "select") {
            const list = (optsByKey.get(k) || []).filter(s => s !== "");
            const def = rule.default || (list[0] || "");
            perTier[T] = { kind: "select", options: list, ...(def ? { default: def } : {}) };
          }
        }
        catalog.push({
          id: f.id,
          group: f.group || undefined,
          label: f.label,
          ...(f.help ? { help: f.help } : {}),
          perTier
        });
      }
      return catalog;
    }

    (async function maybeLoadSheets(){
      try {
        const qs = new URLSearchParams(location.search);
        const featuresCsv = qs.get("features");
        const tierrulesCsv = qs.get("tierrules");
        const optionsCsv = qs.get("options");
        if (featuresCsv && tierrulesCsv && optionsCsv) {
          const data = await loadCatalogFromSheets({ featuresCsv, tierrulesCsv, optionsCsv });
          window.CATALOG_OVERRIDE = data; // consumed by app’s loader
          console.log("Loaded catalog from Google Sheets CSVs:", data);
        }
      } catch (e) {
        console.warn("Sheet loader failed:", e);
      }
    })();
  })();
  </script>
  
</head>
<body class="antialiased">
  <div id="root"></div>

  <script type="text/babel">
    const { useMemo, useState, useEffect, Fragment } = React;

    // ----------------------------------
    // Data model
    // ----------------------------------
    const TIERS = ["Essential", "Advanced", "Premier"];

    // Default catalog (used if config JSON can't be fetched)
    const DEFAULT_CATALOG = [
          {
            "id": "group1:feature1",
            "group": "Group 1",
            "label": "Feature 1",
            "perTier": {
              "Essential": { "kind": "single", "text": "Option 1" },
              "Advanced": {
                "kind": "select",
                "options": ["Option 1", "Option 2", "Option 3"],
                "default": "Option 1"
              },
              "Premier": {
                "kind": "select",
                "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
                "default": "Option 2"
              }
            }
          },
          {
            "id": "group1:feature2",
            "group": "Group 1",
            "label": "Feature 2",
            "perTier": {
              "Essential": { "kind": "flag", "available": true },
              "Advanced": { "kind": "flag", "available": false },
              "Premier": { "kind": "flag", "available": true }
            }
          },
          {
            "id": "group2:feature3",
            "group": "Group 2",
            "label": "Feature 3",
            "perTier": {
              "Essential": { "kind": "single", "text": "Basic" },
              "Advanced": { "kind": "single", "text": "Standard" },
              "Premier": { "kind": "single", "text": "Premium" }
            }
          },
          {
            "id": "group2:feature4",
            "group": "Group 2",
            "label": "Feature 4",
            "perTier": {
              "Essential": { "kind": "flag", "available": false },
              "Advanced": {
                "kind": "select",
                "options": ["Enabled", "Disabled"],
                "default": "Enabled"
              },
              "Premier": {
                "kind": "select",
                "options": ["Enabled", "Disabled", "Custom"],
                "default": "Custom"
              }
            }
          },
          {
            "id": "group3:feature5",
            "group": "Group 3",
            "label": "Feature 5",
            "perTier": {
              "Essential": { "kind": "single", "text": "Included" },
              "Advanced": { "kind": "single", "text": "Included" },
              "Premier": { "kind": "single", "text": "Included + Extras" }
            }
          },
          {
            "id": "group3:feature6",
            "group": "Group 3",
            "label": "Feature 6",
            "perTier": {
              "Essential": { "kind": "flag", "available": false },
              "Advanced": { "kind": "flag", "available": true },
              "Premier": { "kind": "flag", "available": true }
            }
          }
        ];

    // ----------------------------------
    // Small UI helpers
    // ----------------------------------
    function CellFlag({ available }) {
      return <div className="flex items-center justify-center py-2">{available ? "✓" : "✗"}</div>;
    }
    function CellSingle({ text }) {
      return <div className="py-2 text-sm text-center">{text}</div>;
    }
    function CellSelect({ value, options, onChange }) {
      return (
        <div className="py-1 flex justify-center">
          <select
            className="w-60 border rounded px-2 py-1"
            value={value}
            onChange={(e)=>onChange(e.target.value)}
          >
            {options.map(o => <option key={o} value={o}>{o}</option>)}
          </select>
        </div>
      );
    }
    const TierBadge = ({ tier }) => (
      <span className="inline-flex items-center text-xs font-medium rounded-full px-3 py-1 bg-gray-100">{tier}</span>
    );
    const GroupHeader = ({ name }) => (
      <div className="col-span-4 mt-8 mb-2">
        <div className="text-xs uppercase tracking-wider text-gray-500">{name}</div>
        <div className="mt-1 h-px bg-gray-200" />
      </div>
    );

    // ----------------------------------
    // App
    // ----------------------------------
    function App() {
      const [choices, setChoices] = useState({});
      const [catalog, setCatalog] = useState(null);
      const [copied, setCopied] = useState(null);

      // Load order:
      // 1) Google Sheets override (window.CATALOG_OVERRIDE)
      // 2) External ?config=<URL>
      // 3) Relative ./config/catalog.json (repo-aware)
      // 4) DEFAULT_CATALOG
      useEffect(() => {
        (async () => {
          // 1) Sheets override
          if (window.CATALOG_OVERRIDE) {
            setCatalog(window.CATALOG_OVERRIDE);
            return;
          }

          // Helper: compute base path of current page (supports /docs/)
          const here = window.location.pathname;
          const base = here.endsWith("/") ? here : here.replace(/[^/]+$/, "");

          // 2) External ?config=
          const params = new URLSearchParams(window.location.search);
          const external = params.get("config");

          const candidates = [
            external,
            `${base}config/catalog.json`, // e.g. docs/config/catalog.json
          ].filter(Boolean);

          for (const u of candidates) {
            try {
              const url = u.includes("?") ? u : `${u}?t=${Date.now()}`; // cache-bust while testing
              const r = await fetch(url, { cache: "no-store" });
              if (!r.ok) continue;
              const data = await r.json();
              if (Array.isArray(data)) {
                setCatalog(data);
                return;
              }
            } catch (e) { /* try next */ }
          }

          setCatalog(DEFAULT_CATALOG);
        })();
      }, []);

      const activeCatalog = catalog ?? DEFAULT_CATALOG;

      const grouped = useMemo(() => {
        const groups = {};
        activeCatalog.forEach((f) => {
          const g = f.group || "Other";
          groups[g] = groups[g] || [];
          groups[g].push(f);
        });
        return groups;
      }, [activeCatalog]);

      const summary = useMemo(() => {
        const out = {
          Essential: { selects: [], flags: [] },
          Advanced:  { selects: [], flags: [] },
          Premier:   { selects: [], flags: [] },
        };
        activeCatalog.forEach((f) => {
          TIERS.forEach((t) => {
            const rule = f.perTier[t];
            if (rule.kind === "flag") {
              out[t].flags.push({ label: f.label, value: rule.available ? "Yes" : "No" });
            } else if (rule.kind === "single") {
              out[t].flags.push({ label: f.label, value: rule.text });
            } else {
              const val = (choices[f.id]?.[t]) ?? rule.default ?? rule.options[0];
              out[t].selects.push({ label: f.label, value: val });
            }
          });
        });
        return out;
      }, [choices, activeCatalog]);

      const exportMarkdown = () => {
        const lines = [];
        TIERS.forEach((t) => {
          lines.push(`# ${t}`);
          summary[t].flags.forEach(({ label, value }) => lines.push(`- ${label}: ${value}`));
          summary[t].selects.forEach(({ label, value }) => lines.push(`- ${label}: ${value}`));
          lines.push("");
        });
        const blob = new Blob([lines.join("\n")], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "tier-selections.md";
        a.click();
        URL.revokeObjectURL(url);
      };

      const toMachineJSON = () => {
        const payload = {
          generatedAt: new Date().toISOString(),
          tiers: TIERS,
          selections: TIERS.reduce((acc, t) => {
            const byFeature = {};
            activeCatalog.forEach((f) => {
              const rule = f.perTier[t];
              if (rule.kind === "flag") byFeature[f.id] = rule.available;
              else if (rule.kind === "single") byFeature[f.id] = rule.text;
              else byFeature[f.id] = (choices[f.id]?.[t]) ?? rule.default ?? rule.options[0];
            });
            acc[t] = byFeature;
            return acc;
          }, {}),
          catalogVersion: "external-or-default",
        };
        return payload;
      };

      const copyJSON = async () => {
        const payload = toMachineJSON();
        await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
        setCopied("Selections JSON copied to clipboard");
        setTimeout(() => setCopied(null), 2000);
      };

      return (
        <div className="min-h-screen p-6 md:p-10">
          <div className="container mx-auto bg-white shadow rounded-lg border">
            <div className="p-6 border-b">
              <h1 className="text-2xl font-semibold">Tiered Product Configurator</h1>
              <p className="text-sm text-gray-600 mt-1">
                Choose feature options for <strong>Essential</strong>, <strong>Advanced</strong>, and <strong>Premier</strong>.
                Some features are fixed per tier; a few allow a single choice to keep delivery effort predictable.
              </p>
            </div>

            <div className="p-6">
              {/* Header */}
              <div className="grid grid-cols-4 items-center gap-2 px-2 pb-3">
                <div />
                {TIERS.map((t) => (
                  <div key={t} className="text-center font-semibold">
                    <TierBadge tier={t} />
                  </div>
                ))}
              </div>

              {/* Groups */}
              {Object.entries(grouped).map(([gname, feats]) => (
                <div key={gname}>
                  <GroupHeader name={gname} />
                  <div className="grid grid-cols-4 gap-y-3">
                    {feats.map((f) => (
                      <Fragment key={f.id}>
                        <div className="pr-4 py-2">
                          <div className="text-[0.95rem] leading-5 font-medium">{f.label}</div>
                          {f.help && <div className="text-xs text-gray-500 mt-0.5">{f.help}</div>}
                        </div>

                        {TIERS.map((t) => {
                          const rule = f.perTier[t];
                          if (rule.kind === "flag") return <CellFlag key={`${f.id}:${t}`} available={rule.available} />;
                          if (rule.kind === "single") return <CellSingle key={`${f.id}:${t}`} text={rule.text} />;
                          const val = choices[f.id]?.[t] ?? rule.default ?? rule.options[0];
                          return (
                            <CellSelect
                              key={`${f.id}:${t}`}
                              value={val}
                              options={rule.options}
                              onChange={(v) =>
                                setChoices((prev) => ({
                                  ...prev,
                                  [f.id]: { ...(prev[f.id] || {}), [t]: v },
                                }))
                              }
                            />
                          );
                        })}
                      </Fragment>
                    ))}
                  </div>
                </div>
              ))}

              <div className="mt-8 flex flex-col md:flex-row gap-3 items-start md:items-center justify-between">
                <div className="text-xs text-gray-600">
                  Unavailable features show a ✗. {copied && <span className="text-green-600 ml-2">{copied}</span>}
                </div>
                <div className="flex gap-2">
                  <button className="px-3 py-2 text-sm rounded border" onClick={exportMarkdown}>
                    Export selections (Markdown)
                  </button>
                  <button className="px-3 py-2 text-sm rounded border bg-gray-50" onClick={copyJSON}>
                    Copy config (JSON)
                  </button>
                </div>
              </div>
            </div>
          </div>

          <footer className="container mx-auto text-xs text-gray-500 mt-4 px-2">
            Tip: Provide <code>?config=&lt;URL&gt;</code> to load a remote catalog, or host <code>/config/catalog.json</code>.
          </footer>
        </div>
      );
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
